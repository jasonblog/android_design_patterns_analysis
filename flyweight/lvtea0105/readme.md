Android設計模式源碼解析之享元模式

本文為 Android 設計模式源碼解析 中 享元模式 分析

Android系統版本： 4.0

分析者：lvtea0105，分析狀態：未完成，校對者：Mr.Simple，校對狀態：未開始

1. 模式介紹

模式的定義

    通過共享有效支持大量的細粒度對象，節省系統中重複創建相同內容對象的性能消耗，進而提高應用程序的性能。
    享元模式可分為單純享元模式和複合享元模式。

模式的使用場景

    面向對象編程在某些情況下會創建大量的細粒度對象，它們的產生，存儲，銷燬都會造成資源和性能上的損耗，
    可能會在程序運行時形成效率瓶頸，在遇到以下情況時，即可考慮使用享元模式：
    （1）一個應用程序使用了大量的對象，耗費大量的內存，降低了系統的效率。
    （2）這些對象的狀態可以分離出內外兩部分。
    （3）這些對象按照狀態分成很多的組，當把刪除對象的外部狀態時，可以用相對較少的共享對象取代很多組對象。 
    （4）應用程序不依賴這些對象的身份，即這些對象是不可分辨的。
    在一般的開發中享元模式並不常用，其常常應用於系統底層的開發，以便解決系統的性能問題。

2. UML類圖

3. 模式的簡單實現

簡單實現的介紹

（1）享元模式如何實現共享

    將事物的共性共享，同時又保留它的個性。為了做到這點，享元模式中區分了內蘊狀態(Internal State)和
        外蘊狀態(External State)。內蘊狀態就是共性，外蘊狀態就是個性了。
    內蘊狀態存儲在享元內部，不會隨環境改變而變化，是可以共享的；
    外蘊狀態是不可以共享的，它隨環境的改變而變化，通常外蘊狀態是由客戶端來保持的（因為環境的變化是由客戶端引起的）。


單純享元模式

————所有的享元對象都是可以共享的

    抽象享元(Flyweight)角色 ：給出一個抽象接口，以規定出所有具體享元角色需要實現的方法，外蘊狀態以參數形式傳入此方法。
    具體享元(ConcreteFlyweight)角色：實現抽象享元角色定義的接口。如果有內蘊狀態的話，則必須為內蘊狀態提供存儲空間。
    享元工廠(FlyweightFactory)角色：負責創建和管理享元角色，保證享元對象可以被系統適當地共享。
        當客戶端調用一個享元對象的時候，享元工廠角色會檢查系統中是否已經有一個符合要求的享元對象。
        如果已經有了，就提供這個已有的享元對象；如果沒有，就創建一個合適的享元對象。
    客戶端角色：維護所有享元對象的引用，同時還需要存儲享元對象所對應的外蘊狀態。


複合享元模式

————將一些單純享元使用合成模式加以複合，形成複合享元對象。複合享元對象本身是不能共享的，
    但是它們可以分解成能夠進行共享的單純享元對象。

    抽象享元(Flyweight)角色 ：給出一個抽象接口，以規定出所有具體享元角色需要實現的方法，外蘊狀態以參數形式傳入此方法。
    具體享元(ConcreteFlyweight)角色：實現抽象享元角色定義的接口。如果有內蘊狀態的話，則必須為內蘊狀態提供存儲空間。
    複合享元(ConcreteCompositeFlyweight)角色：複合享元角色所代表的對象是不可以共享的，
        但是一個複合享元對象可以分解成能夠進行共享的單純享元對象。
    享元工廠(FlyweightFactory)角色：負責創建和管理享元角色，保證享元對象可以被系統適當地共享。
        當客戶端調用一個享元對象的時候，享元工廠角色會檢查系統中是否已經有一個符合要求的享元對象。
        如果已經有了，就提供這個已有的享元對象；如果沒有，就創建一個合適的享元對象。
    客戶端角色：維護所有享元對象的引用，同時還需要存儲享元對象所對應的外蘊狀態。

實現源碼

Android源碼中的模式實現

4. 優點與缺點
    優點————大幅度地降低內存中對象的數量，節省系統資源的開銷

    缺點————1、為了使對象可以共享，享元模式需要將部分狀態外部化，使得系統的邏輯變得複雜。
            2、讀取狀態外部化的享元對象，影響了系統速度，使運行時間有所加長。
